<html lang="en">
	<head>
		<title>Ray Bundles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
</head>
<body>

	<!-- SHADER CODE -->

  	<!-- Basic Vertex Shader -->
  	<script type="x-shader/x-vertex" id="vertexShaderIn">
    	precision mediump float;
    	precision mediump int;

    	uniform mat4 modelViewMatrix; // optional
    	uniform mat4 projectionMatrix; // optional

    	attribute vec3 position;
    	void main()
    	{
      		vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      		gl_Position = projectionMatrix * modelViewPosition;
    	}
  	</script>
  	<!-- Basic Fragment Shader -->
  	<script type="x-shader/x-fragment" id="fragmentShaderIn">
    	precision mediump float;
    	precision mediump int;

    	void main()
    	{
      		gl_FragColor = vec4(1.0);
    	}
  	</script>

	<!-- Crease Vertex Shader -->
	<script type="x-shader/x-vertex" id="vertexShaderCrease">
		precision mediump float;
		precision mediump int;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec3 normal;

		varying vec3 vNormal;

		void main()
		{
			vNormal = normal;
			vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
			gl_Position = projectionMatrix * modelViewPosition;
		}
	</script>
	<!-- Crease Fragment Shader -->
	<script type="x-shader/x-fragment" id="fragmentShaderCrease">
		#ifdef GL_ES
			#extension GL_OES_standard_derivatives:enable
		#endif

		precision mediump float;
		precision mediump int;

		varying vec3 vNormal;

		void main()
		{
			float difference = 0.0;
			difference += abs(dFdx(vNormal.x));
			difference += abs(dFdx(vNormal.y));
			difference += abs(dFdx(vNormal.z));
			difference += abs(dFdy(vNormal.x));
			difference += abs(dFdy(vNormal.y));
			difference += abs(dFdy(vNormal.z));
			if (difference > 1.0)
			{
				gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
			} else {
				discard;
			}
		}
	</script>

  	<!-- Outline Vertex Shader -->
  	<script type="x-shader/x-vertex" id="vertexShaderOut">
    	precision mediump float;
    	precision mediump int;

    	uniform mat4 modelViewMatrix; // optional
    	uniform mat4 projectionMatrix; // optional

    	attribute vec3 position;
    	attribute vec3 normal;

    	void main()
    	{
      		vec4 modelViewPosition = modelViewMatrix * vec4(position + normal * 0.02, 1.0);
      		gl_Position = projectionMatrix * modelViewPosition;
    	}
  	</script>
  	<!-- Outline Fragment Shader -->
  	<script type="x-shader/x-fragment" id="fragmentShaderOut">
    	precision mediump float;
    	precision mediump int;

    	uniform vec3 color;

    	void main()
    	{
      		gl_FragColor = vec4(color,1.0);
    	}
  	</script>

  	<script src="https://threejs.org/build/three.js"></script>
  	<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

	<!-- MAIN JS CODE -->
	<script>
    	"use strict";
    	let camera, scene, renderer, json, inMaterial, outMaterial, creaseMaterial;

    	class GroupedScene {
			// Handles rendering of rays and meshes (Aids rendering of outlined meshes)
        	constructor() {
            	this.rays = new THREE.Scene();
				// Inner mesh and outer meshes are rendered in two separate passes to give
				// transparent effect.
            	this.innerMeshes = new THREE.Scene();
            	this.outerMeshes = new THREE.Scene();
				// Crease mesh is rendered in yet another pass.
				this.creaseMeshes = new THREE.Scene();

				// Involved in initial placement and zoom of the camera within the scene.
            	this.minCoords = new THREE.Vector3(null, null, null);
            	this.maxCoords = new THREE.Vector3(null, null, null);
				// Boolean flag that tells obj whether any meshes have been added to the scene.
				// (Allows the first mesh placed in scene to become the baseline bounding box)
				this.targetAvailable = false;
        	}

        	renderThis() {
            	renderer.clear();

				// Render all rays first
            	renderer.render(this.rays, camera);

				// Render the outlined meshes using colorMask technique
            	let gl = renderer.domElement.getContext('webgl');
            	renderer.autoClear = false;
            	gl.colorMask(false, false, false, false);
            	renderer.render(this.innerMeshes, camera);
            	gl.colorMask(true, true, true, true);
            	renderer.render(this.outerMeshes, camera);

				// Render the crease meshes
				renderer.render(this.creaseMeshes, camera);
        	}

			getCameraTarget() {
				// Return the center of the scene's bounding box. If no bounding box exists, set
				// center to Vector3(0, 0, 0)
				let center = new THREE.Vector3(0, 0, 0);
				if (this.minCoords.x != null) {
					center.add(this.minCoords);
					center.add(this.maxCoords);
					center.multiplyScalar(0.5);
				}
				return center;
			}

        	updateSceneBox(mesh) {
				// Update the scene's bounding box by checking if the input mesh will increase the
				// current bounding box
				mesh.geometry.computeBoundingBox();

				// If a mesh has yet to be added, this mesh's bounding box becomes the current
				// bounding box.
            	if (this.targetAvailable == false) {
                	this.minCoords = mesh.geometry.boundingBox.min;
                	this.maxCoords = mesh.geometry.boundingBox.max;
					this.targetAvailable = true;
					return;
            	}
				// Checks if the current mesh would update the scene's bounding box in any way
				if (this.minCoords.x < mesh.geometry.boundingBox.min.x) this.minCoords.x = mesh.geometry.boundingBox.min.x;
				if (this.minCoords.y < mesh.geometry.boundingBox.min.y) this.minCoords.y = mesh.geometry.boundingBox.min.y;
				if (this.minCoords.z < mesh.geometry.boundingBox.min.z) this.minCoords.z = mesh.geometry.boundingBox.min.z;
				if (this.maxCoords.x > mesh.geometry.boundingBox.max.x) this.maxCoords.x = mesh.geometry.boundingBox.max.x;
				if (this.maxCoords.y > mesh.geometry.boundingBox.max.y) this.maxCoords.y = mesh.geometry.boundingBox.max.y;
				if (this.maxCoords.z > mesh.geometry.boundingBox.max.z) this.maxCoords.z = mesh.geometry.boundingBox.max.z;
        	}

        	addMeshes(innerMesh, outerMesh, creaseMesh) {
				// Add a mesh to the scene. This will add them to the rendering pipeline as well as
				// automatically update the scene's bounding box if needed.
            	this.updateSceneBox(outerMesh);
            	this.innerMeshes.add(innerMesh);
            	this.outerMeshes.add(outerMesh);
				this.creaseMeshes.add(creaseMesh);
        	}

        	addRays(lineMesh) {
				// Add a ray bundle to the scene (or any line mesh). This will add them to the
				// rendering pipeline as well as automatically update the scene's bounding box if needed.
				this.updateSceneBox(lineMesh);
            	this.rays.add(lineMesh);
        	}
    	}

    	init();

    	function init() {
			// RENDERER
			renderer = new THREE.WebGLRenderer({antialias: true});
			renderer.autoClear = false;
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			window.addEventListener( 'resize', onWindowResize, false );
			document.body.appendChild( renderer.domElement );
			renderer.setClearColor(0x000000, 1);

			// CUSTOM SCENE OBJECT
			scene = new GroupedScene();

			// MATERIALS

			// Basic 3D Mesh material (Used by inner mesh in outlined mesh rendering)
			inMaterial = new THREE.RawShaderMaterial( {
			    vertexShader: document.getElementById('vertexShaderIn').textContent,
			    fragmentShader: document.getElementById('fragmentShaderIn').textContent,
			});

			// Crease 3D Mesh material
			creaseMaterial = new THREE.RawShaderMaterial( {
				vertexShader: document.getElementById('vertexShaderCrease').textContent,
				fragmentShader: document.getElementById('fragmentShaderCrease').textContent
			});

			// Outline 3D Mesh material (Used by outer mesh in outlined mesh rendering)
			outMaterial = new THREE.RawShaderMaterial( {
			    uniforms: {
			    color: {type: "v3", value: new THREE.Vector3( 1, 0, 1 ) }
			    },
			    side:THREE.BackSide,
			    vertexShader: document.getElementById('vertexShaderOut').textContent,
			    fragmentShader: document.getElementById('fragmentShaderOut').textContent
			});

			// CAMERA
			camera = new THREE.PerspectiveCamera( 36, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.position.set( 0, 0, 0 );

			// CAMERA CONTROLS (ORBIT CONTROLS)
			let controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.update();
			controls.addEventListener('change', render);

			// JSON SCENE DEFINITION
			//new THREE.FileLoader().load("raybundle.json",function(json){console.log(json);})

			// Reads JSON file from sessionStorage. If this application is run without
			// running the file selector page, default to using a JSON file called
			// raybundle.json inside the Bundles directory.
			let filename = sessionStorage.getItem('JSONFile');
			if (filename == null) {
				filename = 'Bundles/raybundle.json';
			} else {
				filename = 'Bundles/' + filename;
			}
			// Using the input JSON file name, load the JSON.
			readTextFile(filename, function(text){
				// Load scene definnitions
			    let myObj = JSON.parse(text);
			    loadRayBundles(myObj, 1.0);
			    loadScene(myObj);
			    // Set orbit controls center to scene center.
			    let targetVec = scene.getCameraTarget();
			    controls.target.set(targetVec.x, targetVec.y, targetVec.z);
			    controls.update();
				// Zoom camera by 3x the range of the scene's bounding box z-coords.
			    camera.position.set( targetVec.x, targetVec.y, (scene.maxCoords.z-scene.minCoords.z)*3.0 );
			    render();
			});
    	}

    	function onWindowResize() {
      		camera.aspect = window.innerWidth / window.innerHeight;
      		camera.updateProjectionMatrix();
      		renderer.setSize( window.innerWidth, window.innerHeight );
    	}

    	function render() {
			// Quicker call to the custom scene object's render function
      		scene.renderThis();
    	}

    	function loadRayBundles(json, sf=1.0) {
			// Load in ray bundles from JSON. Add each ray in bundle to scene's rays group.
        	json.rayBundles.forEach(function(item, index, array) {
				// Generate random color in HSL format
            	let h = Math.floor(Math.random() * 360);
            	let s = Math.floor(Math.random() * 50 + 50);
            	let l = Math.floor(Math.random() * 25 + 50);
            	let length = item.length;
            	let material = new THREE.LineBasicMaterial({color: new THREE.Color("hsl("+h+","+s+"%,"+l+"%)")});
				// Construct line segment geometry and mesh, then add to scene
            	let geometry = new THREE.Geometry();
            	for (let i=0; i < length; i+=6) {
              		geometry.vertices.push(new THREE.Vector3(item[i]*sf, item[i+1]*sf, item[i+2]*sf),
                   	                       new THREE.Vector3(item[i+3]*sf, item[i+4]*sf, item[i+5]*sf));
            	}
            	let rayMesh = new THREE.LineSegments(geometry, material);
            	scene.addRays(rayMesh);
        	});
    	}

	    function loadSphereGeometries(object) {
			// Load spheres from JSON. Add each sphere to scene's meshes group.
        	for (let i = 0; i < object.quadruples.length; i += 4) {
				// Quadruple: xPos, yPos, zPos, radius

				// Color only has 3 values per sphere while quad has 4 values per sphere.
	            let colorIndex = i * 3 / 4;
				// Construct material based off outline material. Need to clone outline material because
				// we will be changing its color for each sphere. No need to change color of inner material.
            	let localoutMaterial = outMaterial.clone();
            	localoutMaterial.uniforms.color.value.set(object.color[colorIndex]/255, object.color[colorIndex+1]/255, object.color[colorIndex+2]/255);
				// Construct sphere geometry and translate to proper position.
            	let geometry = new THREE.SphereGeometry(object.quadruples[i+3], 50, 50);
            	geometry.translate(object.quadruples[i], object.quadruples[i+1], object.quadruples[i+2]);
				// Create separate meshes for outlining algorithm and add them to their respective scenes.
            	let innerMesh = new THREE.Mesh(geometry, inMaterial);
            	let outerMesh = new THREE.Mesh(geometry, localoutMaterial);
				let creaseMesh = new THREE.Mesh(geometry, creaseMaterial);
            	scene.addMeshes(innerMesh, outerMesh, creaseMesh);
        	}
    	}

    	function loadTriangleMeshGeometries(object) {
			// Load triangle meshes from JSON. Add each triangle to scene's meshes group.
        	let colorIndex = 0;
			// Vertices are stored in a 2D array where each row is a new mesh.
			// Each row is a 1D array that contains 3n floating values for x, y, z, vertice positions.
			//
			// Faces are stored in a 2D array where each row is a new mesh.
			// Each row is a 1D array that contains 3n int values for vertex indices to connect.
        	for (let meshIndex = 0; meshIndex < object.vertices.length; meshIndex++) {
				// Get vertex and face arrays for the current mesh.
            	let meshVertices = object.vertices[meshIndex];
            	let meshFaces = object.faces[meshIndex];

				// Construct geometry based on vertex and face information.
            	let geometry = new THREE.Geometry();
            	for (let vertexIndex = 0; vertexIndex < meshVertices.length; vertexIndex += 3) {
                	let v1 = meshVertices[vertexIndex];
                	let v2 = meshVertices[vertexIndex+1];
                	let v3 = meshVertices[vertexIndex+2];
                	geometry.vertices.push(new THREE.Vector3(v1, v2, v3));
            	}
            	for (let faceIndex = 0; faceIndex < meshFaces.length; faceIndex += 3) {
                	let f1 = meshFaces[faceIndex];
                	let f2 = meshFaces[faceIndex+1];
                	let f3 = meshFaces[faceIndex+2];
                	geometry.faces.push(new THREE.Face3(f1, f2, f3));
            	}

				// Compute normals for use in outlining algorithm.
            	geometry.computeFaceNormals();
            	geometry.computeVertexNormals();
				// Construct material based off outline material. Need to clone outline material because
				// we will be changing its color for each sphere. No need to change color of inner material.
            	let localoutMaterial = outMaterial.clone();
            	localoutMaterial.uniforms.color.value.set(object.color[colorIndex]/255, object.color[colorIndex+1]/255, object.color[colorIndex+2]/255);
				// Create separate meshes for outlining algorithm and add them to their respective scenes.
				let innerMesh = new THREE.Mesh(geometry, inMaterial);
				let outerMesh = new THREE.Mesh(geometry, localoutMaterial);
				let creaseMesh = new THREE.Mesh(geometry, creaseMaterial);
            	scene.addMeshes(innerMesh, outerMesh, creaseMesh);

				// Color index needs to be bumped up by 3 for next mesh (each mesh has r, g, b values for color)
            	colorIndex += 3;
        	}
    	}

    	function loadScene(json) {
			//let geometry = new THREE.BoxGeometry(1, 1, 1);
			//let innerMesh = new THREE.Mesh(geometry, inMaterial);
			//let outerMesh = new THREE.Mesh(geometry, outMaterial);
			//let creaseMesh = new THREE.Mesh(geometry, creaseMaterial);
			//scene.addMeshes(innerMesh, outerMesh, creaseMesh);
			//return;
			// Load in scene definitions from JSON. Each type of mesh defined by item.type will
			// be handled in a separate helper function.
        	json.scene.forEach(function(item, index, array) {

            	if (item.type == "spheres") {
                	loadSphereGeometries(item);
            	}

            	if (item.type == "triangles") {
                	loadTriangleMeshGeometries(item);
            	}
        	});
    	}

    	function readTextFile(file, callback) {
			// Read in JSON file.
        	var rawFile = new XMLHttpRequest();
        	rawFile.overrideMimeType("application/json");
        	rawFile.open("GET", file, true);
        	rawFile.onreadystatechange = function() {
            	if (rawFile.readyState === 4 && rawFile.status == "200") {
                	callback(rawFile.responseText);
            	}
        	}
        	rawFile.send(null);
    	}

    	function loadObj(file) {
			// Load obj file and add object to scene's objs group.
        	let loader = new THREE.OBJLoader();
        	loader.load(
            	file,
            	function(object) {
                	scene.add(object);
            	},
            	function(xhr) {
                	console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            	},
            	function(error) {
                	console.log('An error happened');
            	}
        	);
    	}
	</script>
</body>
</html>
